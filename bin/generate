#!/usr/bin/env node
'use strict';

var config = require('../config'),
    Promise = require("bluebird"),
    program = require('commander'),
    path = require('path'),
    fs = require('fs'),
    fsx = require('fs.extra'),
    Log = require('console-log-level'),
    hasha = require('hasha'),
    which = require('which'),
    log,
    util = require('util'),
    exif = require('fast-exif'),
    execFile = util.promisify(require('child_process').execFile),
    leftPad = require('left-pad'),
    sizeOf = util.promisify(require('image-size'));

['vipsthumbnail', 'jpegtran', 'zip', 'montage'].forEach(binary => {
  if (!which.sync(binary, {nothrow: true})) {
    program.help(() => "The mandorty binary \"" + binary + "\" is not present or not in the $PATH.\n");
  }
});

Promise.promisifyAll(fs);

program
  .option('-d, --debug', 'output debug information')
  .option('-t, --title [text]', 'specify a title')
  .option('-e, --desc [text]', 'specify a description')
  .option('-f, --font [name]', 'specify google font name (https://fonts.google.com)')
  .option('-r, --reverse', 'reverse order')
  .arguments('<album>')
  .action(album => (program.album = path.basename(album)))
  .parse(process.argv);

if (!program.album) {
    program.help(txt => "You must specify an album name.\n" + txt);
}

if (program.debug) {
  log = Log({
    level: 'debug',
    prefix: function (level) {
      return new Date().toISOString() + " [" + level + "]";
    }
 });
} else {
  log = Log({ level: 'info' });
}

log.debug('title is', program.title);
log.debug('description is', program.desc);
log.debug('font is', program.font);
log.debug('reverse is', program.reverse);

var folders = {
  albums: path.join(__dirname, '..', 'albums'),
  uploads: path.join(__dirname, '..', 'uploads')
};

folders.album = path.join(folders.albums, program.album);
folders.upload = path.join(folders.uploads, program.album);

if (!fs.existsSync(folders.upload)) {
    program.help(txt => "The upload folder does not exists.\n" + txt);
}

if (!fs.existsSync(folders.albums)) fs.mkdirSync(folders.albums);
if (!fs.existsSync(folders.album)) fs.mkdirSync(folders.album);

['originals', 'previews', 'thumbs'].forEach(folder => {
  folders[folder] = path.join(folders.album, folder);
  if (!fs.existsSync(folders[folder])) fsx.mkdirpSync(folders[folder]);
});

/*
 * Structure of an album
 * {
 *    title: '',
 *    description: '',
 *    font: '',
 *    reverse: false,
 *    dates: {
 *      from: null,
 *      to: null
 *    },
 *    pictures: []
 * }
 *
 * Structure of a picture
 * {
 *    id: 0,
 *    idStr: "00000",
 *    hash: "",
 *    filename: "",
 *    preview: {width: 0, height: 0},
 *    thumb: {width: 0, height: 0},
 *    flex: {width: 0, padding: 0}
 *    ts: 0
 *  }
 */

var album;

if (fs.existsSync(path.join(folders.album, 'album.json'))) {
  album = JSON.parse(fs.readFileSync(path.join(folders.album, 'album.json')));
} else {
  album = {
    reverse: false,
    dates: {},
    pictures: []
  };
}

if (program.reverse) album.reverse = true;
if (program.title) album.title = program.title;
if (program.desc) album.description = program.desc;
if (program.font) album.font = program.font;

/*
 * Read directory in ./uploads
 */
var i = 0;
log.debug('reading upload directory', folders.upload);
/*
 * Keep only *.jpg
 */
fs.readdirAsync(folders.upload).filter(filename => path.extname(filename) === '.jpg')

.map(filename => {
  /*
   * Calculate MD5 checksums
   */
  log.debug('calculting checksum', filename);
  return hasha.fromFile(path.join(folders.upload, filename), {algorithm: 'md5'})
    .then(hash => [filename, hash])
    .catch(() => [filename, false]);

}, {concurrency: 1})

.map(filenameAndHash => {
  /*
   * Create symlinks in ./originals
   */
  var filename = filenameAndHash[0];
  var hash = filenameAndHash[1];

  i++;
  log.debug('found', filename, hash);
  if (album.pictures[i - 1] && hash !== false && album.pictures[i - 1].hash === hash) {
    log.debug('skip (same hash)', filename, hash);
    return false;
  } else {
    var idStr = leftPad(i, 5, 0);
    var target = program.album.replace(/[ _\+\(\)]/g, '-').replace(/-+/, '-') + '-' + idStr + '.jpg';
    album.pictures[i - 1] = {filename: target, id: i, idStr: idStr, hash: hash};
    log.info('symlink', filename, 'to', target);
    if (fs.existsSync(path.join(folders.originals, target))) fs.unlinkSync(path.join(folders.originals, target));
    fs.symlinkSync(path.join(folders.upload, filename), path.join(folders.originals, target));
    return album.pictures[i - 1];
  }
}, {concurrency: 1})
.filter(picture => picture)

.map((picture) => {
  /*
   * Extract dates from EXIF metadata
   */
  return exif.read(path.join(folders.originals, picture.filename)).then(data => {
    var date;
    if (data && data.exif) {
      date = data.exif.DateTimeOriginal || data.exif.DateTimeDigitized || data.image.ModifyDate;
      date = date.toISOString().slice(0, 10);
    }
    if (!album.dates.from || album.dates.from > date) {
      album.dates.from = date;
    }
    if (!album.dates.to || album.dates.to < date) {
      album.dates.to = date;
    }
    return picture;
  });
}, {concurrency: 1})

.map(picture => {
  /*
   * Resize all originals a save them into ./previews/
   */
  var output = path.join(folders.previews, picture.filename);
  log.info("generate preview for", picture.filename);

  return execFile('vipsthumbnail', [
    '-s', config.preview,
    path.join(folders.originals, picture.filename),
    '-o', output + '[Q=' + config.quality + ']'
  ])
  .then(() => execFile('jpegtran', ['-optimize', '-copy', 'none', '-progressive', '-outfile', output, output]))
  .then(() => sizeOf(output))
  .then(dimensions => {
    delete(dimensions.type);
    picture.preview = dimensions;
    return picture;
  });
}, {concurrency: 1})

.map(picture => {
  /*
   * Resize all originals a save them into ./thumbs/
   */
  var output = path.join(folders.thumbs, picture.filename);
  log.info("generate thumb for", picture.filename);

  return execFile('vipsthumbnail', [
    '-s', config.thumb,
    path.join(folders.previews, picture.filename),
    '-o', output + '[Q=' + config.quality + ']'
  ])
  .then(() => execFile('jpegtran', ['-optimize', '-copy', 'none', '-progressive', '-outfile', output, output]))
  .then(() => sizeOf(output))
  .then(dimensions => {
    delete(dimensions.type);
    picture.thumb = dimensions;
    picture.flex = {
      width: Math.floor(dimensions.width * 200 / dimensions.height),
      padding: dimensions.height / dimensions.width * 100
    };
    return picture;
  });
}, {concurrency: 1})

.then(() => {
  /*
   * Save album informations in a JSON file
   */
  log.info('save album meta data');
  return fs.writeFileAsync(path.join(folders.album, 'album.json'), JSON.stringify(album, null, 4));
})

.then(() => {
  /*
   * Generate the album zip file
   */
  log.info("generate the zip file");
  return execFile('zip',
    ['-u', '-X', '-D', '-0', path.join(folders.album, 'album.zip')].concat(album.pictures.map(picture => picture.filename)),
    {cwd: folders.originals});
})
.catch(e => {
  // error code 12 stands for "zip has nothing to do" cf. man
  if (typeof e.cmd !== 'string' || !e.cmd.startsWith('zip') || e.code !== 12) throw e;
})

.then(() => fs.readdirAsync(folders.album))
.each((filename) => {
  /*
   * Remove all zip files that are not the album
   */
  if (filename.match(/\.zip$/) && filename !== 'album.zip') {
    log.info("deleting", filename);
    return fs.unlinkAsync(path.join(folders.album, filename));
  }
})

.then(() => {
  /*
   * Select sample images
   */
  var count = 8;
  var samples = [];
  var filenames = album.pictures.map(picture => picture.filename);
  if (count > album.pictures.length) {
    for (let i = 0; i < count; i++) {
      samples.push(filenames[i % filenames.length]);
    }
  } else {
    for (let i = 0; i < count; i++) {
      var index = Math.floor(Math.random() * filenames.length);
      samples.push(filenames.splice(index, 1)[0]);
    }
  }
  return samples;
})

.map((filename, index) => {
  /*
   * Generate the sample images
   */
  log.info("generate sample image number", index);
  var output = path.join(folders.album, 'sample-' + index + '.jpg');
  return execFile('vipsthumbnail', ['-s', '200x200', '-m', 'attention', path.join(folders.previews, filename), '-o', output + '[Q=' + config.quality + ']'])
    .then(() => output);
})

.then((samples) => {
  /*
   * Generate the sample collage
   */
  log.info("generate samples collage");
  return execFile('montage', ['-background', '#D7D7D7FF', '-tile', '4x2', '-geometry', '200x200+0+0', '-borderwidth', '1', '-bordercolor', '#D7D7D7FF'].concat(samples).concat([path.join(folders.album, 'samples.jpg')]))
    .then(() => samples);
})

.map(sample => fs.unlinkAsync(sample))

.catch(e => {
  log.error(e);
});
